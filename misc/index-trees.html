<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Three.js Instanced Mesh Example</title>
    <style>
      body {
        margin: 0;
      }
      canvas {
        background-color: aqua;
        display: block;
      }
    </style>
    <script type="importmap">
        {
          "imports": {
            "three": "https://unpkg.com/three@v0.156.1/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@v0.156.1/examples/jsm/"
          }
        }
      </script>
  </head>
  <body>
    <!-- <script src="https://threejs.org/build/three.js"></script> -->
    <script type="module">
      // Initialize scene, camera, and renderer
      import * as THREE from 'three';
      import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
       // Initialize scene, camera, and renderer
       const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );

      const renderer = new THREE.WebGLRenderer({ antialias: true});
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);
      scene.background = new THREE.Color(0x000b3f);
      const light =  new THREE.DirectionalLight(0xffffff, 1);
      light.position.set(0, 1, 1);
      const light2 = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(light2); 
      scene.add(light);


      // Hemisphere geometry
      const hemisphereGeometry = new THREE.SphereGeometry(1, 32, 32, 0, Math.PI * 2, 0, Math.PI / 2);

      // Tetrahedron geometry
      // const tetrahedronGeometry = new THREE.TetrahedronGeometry(0.5);
      // tetrahedronGeometry.translate(0, -1, 0);

      // tetrahedronGeometry.rotateX(Math.PI / 2);
      const tetrahedronGeometry = new THREE.CylinderGeometry(0, 0.5, 1, 4, 1)
      // Triangle
      // const triangleGeometry = new THREE.BufferGeometry();
      // triangleGeometry.setAttribute(
      //   'position',
      //   new THREE.Float32BufferAttribute([-0.5, 0, 0, 0.5, 0, 0, 0, 1, 0], 3)
      // );
      // triangleGeometry.setIndex([0, 1, 2]);
      const vertexReplacement =           `
            vec3 transformed = vec3(position);
            transformed.x += sin(position.y * 10.0 + time) * 0.1;
            transformed.z += cos(position.y * 10.0 + time) * 0.1;
          `
      // const triangleMaterial = new THREE.MeshStandardMaterial({ color: 0x0f9f0f, side: THREE.DoubleSide });
      const material = new THREE.MeshStandardMaterial({ color: 0x00ff00,
        side: THREE.DoubleSide
      });
      material.onBeforeCompile = shader => {
        shader.uniforms.time = { value: 0 };
        shader.vertexShader = 'uniform float time;\n' + shader.vertexShader;
        shader.vertexShader = shader.vertexShader.replace(
          '#include <begin_vertex>',
          vertexReplacement
        );
        material.userData.shader = shader;
      };
      const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513,
        side: THREE.DoubleSide
      });


      const triangleGeometry = new THREE.BufferGeometry();

      const vertices = new Float32Array( [
        -1.0, -1.0,  0.0, // v0
        1.0, -1.0,  0.0, // v1
        1.0,  1.0,  0.0, // v2
        -1.0,  1.0,  0.0, // v3
      ] );

      const indices = [
        0, 1, 2,
        2, 3, 0,
      ];

      triangleGeometry.setIndex( indices );
      triangleGeometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
      triangleGeometry.computeVertexNormals();
      triangleGeometry.rotateY(Math.PI)
      const triangleMaterial = new THREE.MeshStandardMaterial( { color: 0x8b4513, side: THREE.DoubleSide } );
      triangleMaterial.onBeforeCompile = shader => {
        shader.uniforms.time = { value: 0 };
        shader.vertexShader = 'uniform float time;\n' + shader.vertexShader;
        shader.vertexShader = shader.vertexShader.replace(
          '#include <begin_vertex>',
          vertexReplacement
        );
        triangleMaterial.userData.shader = shader;
      };
      // const mesh = new THREE.Mesh( triangleGeometry, triangleMaterial );


      // Create separate instanced meshes
      const hemisphereInstancedMesh = new THREE.InstancedMesh(hemisphereGeometry, material, 100);
      const tetrahedronInstancedMesh = new THREE.InstancedMesh(tetrahedronGeometry, trunkMaterial, 100);
  
      const lineInstancedMesh = new THREE.InstancedMesh(triangleGeometry, triangleMaterial, 800);

      const rndScale = 1.5;
      const dummy = new THREE.Object3D();
      for (let i = 0; i < 100; i++) {
        const matrix = new THREE.Matrix4();
        const position = [Math.random() * 50 - 25, Math.random() * 50 - 25, Math.random() * 50 - 25]
        // Random positioning
        if(i > 0) {
        matrix.setPosition(...position);
        // matrix.scale(new THREE.Vector3(Math.random() * 2, Math.random() * 2, Math.random() * 2));
        }
        hemisphereInstancedMesh.setMatrixAt(i, matrix);
        tetrahedronInstancedMesh.setMatrixAt(i, matrix);
        for(let j = 0; j < 8; j++) {
          dummy.matrix.identity();
          dummy.position.set(position[0] + (Math.random() * rndScale) - (0.5*rndScale), position[1], position[2] + (Math.random() * rndScale - 0.5 * rndScale));
          // matrix.setPosition(position[0] + (Math.random() * rndScale) - (0.5*rndScale), position[1], position[2] + (Math.random() * rndScale - 0.5 * rndScale));
          dummy.scale.set(0.03, 0.5, 1);
          dummy.rotateY(Math.PI / 4 * j);
          dummy.updateMatrix();
          // matrix.makeRotationY(Math.PI / 4 * j);

          lineInstancedMesh.setMatrixAt(i * 8 + j, dummy.matrix);
        }
      }

      scene.add(hemisphereInstancedMesh);
      scene.add(tetrahedronInstancedMesh);
      scene.add(lineInstancedMesh);

      camera.position.z = 70;

      function animate() {
        controls.update()
        requestAnimationFrame(animate);

      
        // hemisphereInstancedMesh.rotation.x += 0.005;
        // hemisphereInstancedMesh.rotation.y += 0.005;

        // tetrahedronInstancedMesh.rotation.x += 0.005;
        // tetrahedronInstancedMesh.rotation.y += 0.005;

        // lineInstancedMesh.rotation.x += 0.005;
        // lineInstancedMesh.rotation.y += 0.005;

        renderer.render(scene, camera);
        if(material.userData.shader) { material.userData.shader.uniforms.time.value += 0.03 }
        if(triangleMaterial.userData.shader) { triangleMaterial.userData.shader.uniforms.time.value += 0.03 }
      }

      animate();

      window.addEventListener('resize', () => {
        const newWidth = window.innerWidth;
        const newHeight = window.innerHeight;

        camera.aspect = newWidth / newHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(newWidth, newHeight);

      });
    </script>
  </body>
</html>
